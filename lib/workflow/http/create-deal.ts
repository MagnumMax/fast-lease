"use server";

import { promises as fs } from "node:fs";
import path from "node:path";

import { createSupabaseServiceClient } from "@/lib/supabase/server";
import { buildDealNumberCandidate, DEAL_NUMBER_PREFIX } from "@/lib/deals/deal-number";
import type { AppRole } from "@/lib/auth/types";
import { createSupabaseWorkflowVersionRepository } from "@/lib/supabase/queries/workflow-versions";
import {
  WorkflowVersionService,
  type WorkflowVersionRecord,
} from "@/lib/workflow/versioning";
import {
  DEFAULT_DEAL_COMPANY_CODE,
  getDealCompanyPrefix,
  type DealCompanyCode,
} from "@/lib/data/deal-companies";
import type {
  CreateDealFromReferencesRequest,
  CreateDealRequest,
  CreateDealWithEntitiesRequest,
} from "@/lib/workflow";
import { createWorkflowActionExecutor } from "@/lib/workflow/actions";
import type { WorkflowActionContext } from "@/lib/workflow/state-machine";
import { getWorkflowVersionChecksum } from "@/lib/workflow/versioning";

export type DealRow = {
   id: string;
   workflow_id: string;
   workflow_version_id: string | null;
   client_id: string | null;
   asset_id: string | null;
   vehicle_id: string | null;
   source: string | null;
   status: string;
   op_manager_id: string | null;
   deal_number: string | null;
   company_code: string | null;
   created_at: string;
   updated_at: string;
   payload: Record<string, unknown> | null;
};

type CreateDealResult =
  | { success: true; deal: DealRow }
  | { success: false; statusCode: number; message: string };

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServiceClient>>;

const DEAL_NUMBER_MAX_ATTEMPTS = 50;

async function generateFormattedDealNumber(
  client: SupabaseServerClient,
  options: { createdAt: Date; vin?: string | null; prefix?: string | null },
): Promise<string> {
  const { createdAt, vin = null, prefix = DEAL_NUMBER_PREFIX } = options;

  for (let attempt = 1; attempt <= DEAL_NUMBER_MAX_ATTEMPTS; attempt++) {
    const candidate = buildDealNumberCandidate(createdAt, vin, attempt, prefix);
    const { count, error } = await client
      .from("deals")
      .select("id", { head: true, count: "exact" })
      .eq("deal_number", candidate);

    if (error) {
      console.error("[workflow] failed to verify deal number uniqueness", {
        candidate,
        error,
      });
      continue;
    }

    if (!count) {
      return candidate;
    }
  }

  throw new Error("Failed to generate unique deal number");
}

const DEFAULT_GUARD_PAYLOAD: Record<string, unknown> = {
  quotationPrepared: false,
  vehicle: { verified: false },
  docs: { required: { allUploaded: false } },
  risk: { approved: false },
  finance: { approved: false },
  investor: { approved: false },
  legal: { contractReady: false },
  esign: { allSigned: false },
  payments: {
    advanceReceived: false,
    supplierPaid: false,
  },
  delivery: { confirmed: false },
  price_vat: null,
  term_months: null,
  down_payment_amount: null,
  interest_rate_annual: null,
  insurance_rate_annual: null,
};

function deepMergePayload(
  base: Record<string, unknown>,
  override?: Record<string, unknown> | null,
): Record<string, unknown> {
  if (!override) {
    return { ...base };
  }

  const result: Record<string, unknown> = { ...base };

  for (const [key, value] of Object.entries(override)) {
    const current = result[key];
    if (
      value &&
      typeof value === "object" &&
      !Array.isArray(value) &&
      current &&
      typeof current === "object" &&
      !Array.isArray(current)
    ) {
      result[key] = deepMergePayload(
        current as Record<string, unknown>,
        value as Record<string, unknown>,
      );
      continue;
    }

    result[key] = value;
  }

  return result;
}

let defaultWorkflowSourceCache: string | null = null;

type PostgrestError = {
  code?: string;
  message?: string;
};

function isMissingTableError(error: unknown) {
  if (!error || typeof error !== "object") {
    return false;
  }

  const candidate = error as PostgrestError;
  return candidate.code === "PGRST205";
}

async function loadDefaultWorkflowSource(): Promise<string> {
  if (defaultWorkflowSourceCache) {
    return defaultWorkflowSourceCache;
  }

  const templatePath = path.join(
    process.cwd(),
    "docs",
    "workflow_template.yaml",
  );

  const source = await fs.readFile(templatePath, "utf8");
  defaultWorkflowSourceCache = source;
  return source;
}

type WorkflowVersionSyncOptions = {
  workflowId: string;
  sourceYaml: string;
  checksum: string;
};

function buildAutogeneratedVersionLabel(workflowId: string, checksum: string): string {
  const prefix = workflowId.replace(/[^a-zA-Z0-9_-]/g, "-");
  const timestamp = new Date()
    .toISOString()
    .replace(/\D/g, "")
    .slice(0, 12);
  return `${prefix}-${timestamp}-${checksum.slice(0, 6)}`;
}

async function activateMatchingVersion(
  service: WorkflowVersionService,
  options: WorkflowVersionSyncOptions,
): Promise<WorkflowVersionRecord | null> {
  const versions = await service.listVersions(options.workflowId);
  const match = versions.find((version) => version.checksum === options.checksum);
  if (!match) {
    return null;
  }

  await service.activateVersion(options.workflowId, match.id);
  const activated = await service.getVersionById(match.id);
  return activated ?? null;
}

export async function ensureActiveWorkflowVersion(
  service: WorkflowVersionService,
): Promise<WorkflowVersionRecord | null> {
  const workflowId = "fast-lease-v1";
  const sourceYaml = await loadDefaultWorkflowSource();
  const checksum = getWorkflowVersionChecksum(sourceYaml);

  const existing = await service.getActiveVersion(workflowId);
  if (existing && existing.checksum === checksum) {
    return existing;
  }

  if (existing) {
    console.info("[workflow] detected outdated workflow version, provisioning update", {
      workflowId,
      activeVersionId: existing.id,
    });
  } else {
    console.info("[workflow] no active workflow version found, bootstrapping default", {
      workflowId,
    });
  }

  const syncOptions: WorkflowVersionSyncOptions = {
    workflowId,
    sourceYaml,
    checksum,
  };

  try {
    const reactivated = await activateMatchingVersion(service, syncOptions);
    if (reactivated) {
      return reactivated;
    }

    const versionLabel = buildAutogeneratedVersionLabel(workflowId, checksum);
    const created = await service.createVersion({
      sourceYaml,
      version: versionLabel,
      activate: true,
    });
    return created;
  } catch (error) {
    console.error("[workflow] failed to synchronize workflow version", error);

    const fallback = await service.getActiveVersion(workflowId);
    if (fallback && fallback.checksum === checksum) {
      return fallback;
    }

    return null;
  }
}

type DealCompanyMeta = {
  code: DealCompanyCode;
  prefix: string;
};

async function resolveDealCompanyMeta(
  client: SupabaseServerClient,
  requestedCode?: string | null,
): Promise<DealCompanyMeta> {
  const fallback: DealCompanyMeta = {
    code: DEFAULT_DEAL_COMPANY_CODE,
    prefix: getDealCompanyPrefix(DEFAULT_DEAL_COMPANY_CODE),
  };

  const normalizedCode = (requestedCode ?? DEFAULT_DEAL_COMPANY_CODE).toUpperCase();

  try {
    const { data, error } = await client
      .from("deal_companies")
      .select("code, prefix")
      .eq("code", normalizedCode)
      .maybeSingle();

    if (error) {
      if (!isMissingTableError(error)) {
        console.error("[workflow] failed to load deal company", error);
      }
      return fallback;
    }

    if (!data) {
      return fallback;
    }

    const prefix = typeof data.prefix === "string" && data.prefix.trim().length > 0
      ? data.prefix.trim().toUpperCase()
      : fallback.prefix;

    const code = (data.code as DealCompanyCode | null) ?? fallback.code;

    return { code, prefix };
  } catch (error) {
    console.error("[workflow] unexpected error while resolving deal company", error);
    return fallback;
  }
}

type CustomerSnapshot = {
  id: string;
  full_name: string | null;
  email: string | null;
  phone: string | null;
};

type WorkflowAssetSnapshot = {
  id: string;
  type: string | null;
  make: string | null;
  model: string | null;
  trim: string | null;
  year: number | null;
  vin: string | null;
  supplier: string | null;
  price: number | null;
  meta: Record<string, unknown> | null;
};

async function loadClientCustomerSnapshot(
  supabase: SupabaseServerClient,
  clientId: string,
): Promise<CustomerSnapshot | null> {
  const { data: profile, error: profileError } = await supabase
    .from("profiles")
    .select("user_id, full_name, phone, metadata")
    .eq("user_id", clientId)
    .maybeSingle();

  if (profileError) {
    console.error("[workflow] failed to load profile for client snapshot", {
      clientId,
      error: profileError,
    });
    return null;
  }

  if (!profile) {
    return null;
  }

  let email: string | null = null;
  try {
    const { data: authUser, error: authError } = await supabase.auth.admin.getUserById(clientId);
    if (authError) {
      console.error("[workflow] failed to load auth user for client snapshot", {
        clientId,
        error: authError,
      });
    } else {
      email = authUser?.user?.email ?? null;
    }
  } catch (adminError) {
    console.error("[workflow] unexpected admin error while loading client snapshot", adminError);
  }

  const metadata = (profile.metadata as Record<string, unknown> | null) ?? null;
  const fallbackPhone =
    typeof metadata?.source_phone === "string" ? (metadata.source_phone as string) : null;

  return {
    id: clientId,
    full_name: profile.full_name,
    email,
    phone: profile.phone ?? fallbackPhone,
  };
}

async function resolveExistingClientId(
  supabase: SupabaseServerClient,
  customer: CreateDealWithEntitiesRequest["customer"],
): Promise<string | null> {
  const email = customer.email?.trim().toLowerCase() ?? null;
  const phone = customer.phone?.trim() ?? null;

  if (email) {
    try {
      let page = 1;
      const perPage = 200;

      while (true) {
        const { data, error } = await supabase.auth.admin.listUsers({ page, perPage });
        if (error) {
          console.error("[workflow] failed to lookup client by email", { email, error });
          break;
        }

        const matched = data?.users?.find(
          (user) => (user.email ?? "").toLowerCase() === email,
        );
        if (matched) {
          return matched.id;
        }

        if (!data?.nextPage) {
          break;
        }

        page = data.nextPage;
      }
    } catch (lookupError) {
      console.error("[workflow] unexpected error during email lookup", lookupError);
    }
  }

  if (phone) {
    try {
      const { data, error } = await supabase
        .from("profiles")
        .select("user_id, phone, metadata")
        .or(`phone.eq.${phone},metadata->>source_phone.eq.${phone}`)
        .limit(1)
        .maybeSingle();

      if (error) {
        console.error("[workflow] failed to lookup client by phone", { phone, error });
      } else if (data) {
        return (data as { user_id: string }).user_id;
      }
    } catch (lookupError) {
      console.error("[workflow] unexpected error during phone lookup", lookupError);
    }
  }

  return null;
}

async function loadWorkflowAsset(
  supabase: SupabaseServerClient,
  id: string,
): Promise<WorkflowAssetSnapshot | null> {
  const { data, error } = await supabase
    .from("workflow_assets")
    .select("id, type, make, model, trim, year, vin, supplier, price, meta")
    .eq("id", id)
    .maybeSingle();

  if (error) {
    console.error("[workflow] failed to load workflow asset", error);
    return null;
  }

  if (!data) {
    return null;
  }

  return data as WorkflowAssetSnapshot;
}

function buildPayloadEnrichment(input: {
  customer?: CustomerSnapshot | null;
  vehicle?: {
    id: string | null;
    asset: WorkflowAssetSnapshot | null;
  };
}): Record<string, unknown> {
  const enrichment: Record<string, unknown> = {};

  if (input.customer) {
    enrichment.customer = {
      id: input.customer.id,
      full_name: input.customer.full_name,
      email: input.customer.email,
      phone: input.customer.phone,
    };
  }

  if (input.vehicle?.asset) {
    enrichment.vehicle = {
      id: input.vehicle.id,
      vin: input.vehicle.asset.vin,
      make: input.vehicle.asset.make,
      model: input.vehicle.asset.model,
      trim: input.vehicle.asset.trim,
      year: input.vehicle.asset.year,
      supplier: input.vehicle.asset.supplier,
      price: input.vehicle.asset.price,
      meta: input.vehicle.asset.meta ?? {},
    };
  }

  return enrichment;
}

function resolveActorRole(role?: string | null): AppRole {
  if (!role) {
    return "OP_MANAGER";
  }
  const normalized = role.trim().toUpperCase();
  if (
    normalized === "ADMIN" ||
    normalized === "OP_MANAGER" ||
    normalized === "SUPPORT" ||
    normalized === "FINANCE" ||
    normalized === "TECH_SPECIALIST" ||
    normalized === "RISK_MANAGER" ||
    normalized === "INVESTOR" ||
    normalized === "LEGAL" ||
    normalized === "ACCOUNTING" ||
    normalized === "CLIENT"
  ) {
    return normalized as AppRole;
  }
  return "OP_MANAGER";
}

export async function createDealWithWorkflow(
  payload: CreateDealRequest,
): Promise<CreateDealResult> {
  try {
    const supabase = await createSupabaseServiceClient();
    const versionService = new WorkflowVersionService(
      createSupabaseWorkflowVersionRepository(supabase),
    );

    const activeVersion = await ensureActiveWorkflowVersion(versionService);

    if (!activeVersion) {
      return {
        success: false,
        statusCode: 500,
        message: "Workflow version is not configured",
      };
    }

    const baseCompanyCode =
      "company_code" in payload && typeof payload.company_code === "string"
        ? payload.company_code
        : DEFAULT_DEAL_COMPANY_CODE;
    const companyMeta = await resolveDealCompanyMeta(supabase, baseCompanyCode);

    let assetId: string | null = null;
    let vehicleId: string | null = null;
    let createdAsset = false;

    let customerSnapshot: CustomerSnapshot | null = null;
    let assetSnapshot: WorkflowAssetSnapshot | null = null;
    let resolvedClientId: string | null = null;

    if ("client_id" in payload && "asset_id" in payload) {
      const referencePayload = payload as CreateDealFromReferencesRequest;
      resolvedClientId = referencePayload.client_id;
      assetId = referencePayload.asset_id;

      customerSnapshot = await loadClientCustomerSnapshot(supabase, resolvedClientId);
      if (!customerSnapshot) {
        return {
          success: false,
          statusCode: 404,
          message: "Client profile snapshot not found",
        };
      }

      assetSnapshot = await loadWorkflowAsset(supabase, assetId);

      if (!assetSnapshot) {
        return {
          success: false,
          statusCode: 404,
          message: "Referenced asset not found",
        };
      }
    } else {
      const { customer, asset } = payload as CreateDealWithEntitiesRequest;

      resolvedClientId = await resolveExistingClientId(supabase, customer);

      if (!resolvedClientId) {
        return {
          success: false,
          statusCode: 400,
          message: "Клиент не найден. Сначала создайте клиента, затем повторите попытку.",
        };
      }

      customerSnapshot = await loadClientCustomerSnapshot(supabase, resolvedClientId);
      if (!customerSnapshot) {
        return {
          success: false,
          statusCode: 404,
          message: "Профиль клиента не найден",
        };
      }

      const assetInsert = await supabase
        .from("workflow_assets")
        .insert({
          type: asset.type ?? "VEHICLE",
          make: asset.make,
          model: asset.model,
          trim: asset.trim ?? null,
          year: asset.year ?? null,
          supplier: asset.supplier ?? null,
          price: asset.price ?? null,
          vin: asset.vin ?? null,
          meta: asset.meta ?? null,
        })
        .select("id, type, make, model, trim, year, vin, supplier, price, meta")
        .single();

        if (assetInsert.error || !assetInsert.data) {
          if (isMissingTableError(assetInsert.error)) {
            console.warn(
              "[workflow] skipping asset creation – table missing",
              assetInsert.error,
            );
          } else {
            console.error("[workflow] failed to create asset", assetInsert.error);
            return {
              success: false,
              statusCode: 500,
              message: "Failed to create asset",
            };
          }
        } else {
        assetId = assetInsert.data.id;
        createdAsset = true;
        assetSnapshot = assetInsert.data as WorkflowAssetSnapshot;
      }
    }

    if (assetId) {
      if (!assetSnapshot) {
        assetSnapshot = await loadWorkflowAsset(supabase, assetId);
      }

      if (assetSnapshot) {
        const assetMeta = (assetSnapshot.meta as Record<string, unknown> | null) ?? null;
        const mileageRaw = assetMeta?.mileage_value as number | string | undefined;
        const mileageValue =
          typeof mileageRaw === "number"
            ? mileageRaw
            : typeof mileageRaw === "string"
              ? Number.parseFloat(mileageRaw)
              : null;
        const vehicleInsert = await supabase
          .from("vehicles")
          .upsert(
            {
              vin: assetSnapshot.vin ?? null,
              make: assetSnapshot.make ?? null,
              model: assetSnapshot.model ?? null,
              variant: assetSnapshot.trim ?? null,
              year: assetSnapshot.year ?? null,
              status: "reserved",
              mileage: mileageValue ?? null,
              features: assetMeta ?? {},
            },
            assetSnapshot.vin
              ? { onConflict: "vin" }
              : undefined,
          )
          .select("id")
          .maybeSingle();

        if (vehicleInsert.error) {
          console.error("[workflow] failed to create vehicle record", vehicleInsert.error);
          if (createdAsset && assetId) {
            await supabase.from("workflow_assets").delete().eq("id", assetId);
          }
          return {
            success: false,
            statusCode: 500,
            message: "Failed to create vehicle record",
          };
        }

        vehicleId = vehicleInsert.data?.id ?? null;
      }
    }

    if (!resolvedClientId) {
      return {
        success: false,
        statusCode: 400,
        message: "Не удалось определить клиента для сделки",
      };
    }

    const mergedPayload = deepMergePayload(
      DEFAULT_GUARD_PAYLOAD,
      payload.payload ?? null,
    );

    const enrichedPayload = deepMergePayload(
      mergedPayload,
      buildPayloadEnrichment({
        customer: customerSnapshot ?? undefined,
        vehicle: {
          id: vehicleId ?? assetId ?? null,
          asset: assetSnapshot ?? null,
        },
      }),
    );
    enrichedPayload.company = {
      code: companyMeta.code,
      prefix: companyMeta.prefix,
    } satisfies Record<string, unknown>;

    const actorRole = resolveActorRole("OP_MANAGER");

    const dealNumber = await generateFormattedDealNumber(supabase, {
      createdAt: new Date(),
      vin: assetSnapshot?.vin ?? null,
      prefix: companyMeta.prefix,
    });
    console.log(`[DEBUG] Generated formatted deal number: ${dealNumber}`);

    const { data, error } = await supabase
      .from("deals")
      .insert({
        workflow_id: activeVersion.workflowId,
        workflow_version_id: activeVersion.id,
        client_id: resolvedClientId,
        asset_id: assetId,
        vehicle_id: vehicleId,
        source: payload.source,
        status: "NEW",
        op_manager_id: payload.op_manager_id ?? null,
        deal_number: dealNumber,
        company_code: companyMeta.code,
        payload: enrichedPayload,
      })
      .select(
        "id, workflow_id, workflow_version_id, client_id, asset_id, vehicle_id, source, status, op_manager_id, deal_number, company_code, created_at, updated_at, payload",
      )
      .single<DealRow>();

    if (error || !data) {
      console.error(`[DEBUG] failed to create deal in database:`, error);
      if (createdAsset && assetId) {
        const cleanupAsset = await supabase
          .from("workflow_assets")
          .delete()
          .eq("id", assetId);
        if (cleanupAsset.error) {
          console.error(
            "[workflow] failed to cleanup asset after deal error",
            cleanupAsset.error,
          );
        }
      }
      console.error("[workflow] failed to create deal", error);
      return {
        success: false,
        statusCode: 500,
        message: "Failed to create deal",
      };
    }

    try {
      const newStage = activeVersion.template.stages?.NEW;
      if (newStage?.entryActions?.length) {
        console.log(
          "[workflow] executing entry actions for NEW stage",
          newStage.entryActions.map((action) => action.type),
        );
        const actionExecutor = createWorkflowActionExecutor(supabase);
        const actionContext: WorkflowActionContext = {
          actorRole,
          actorId: payload.op_manager_id ?? undefined,
          dealId: data.id,
          transition: {
            from: "NEW",
            to: "NEW",
          },
          payload: enrichedPayload,
          template: activeVersion.template,
        };

        for (const action of newStage.entryActions) {
          console.log("[workflow] executing action", action.type);
          await actionExecutor(action, actionContext);
        }
      }
    } catch (actionError) {
      console.error("[workflow] failed to execute entry actions for new deal", actionError);
    }

    console.log(`[DEBUG] successfully created deal:`, data.id, `with deal_number:`, data.deal_number);
    return { success: true, deal: data };
  } catch (error) {
    console.error("[workflow] unexpected error while creating deal", error);
    return {
      success: false,
      statusCode: 500,
      message: "Unexpected error while creating deal",
    };
  }
}

"use server";

import { promises as fs } from "node:fs";
import path from "node:path";

import { createSupabaseServiceClient } from "@/lib/supabase/server";
import { buildDealNumberCandidate } from "@/lib/deals/deal-number";
import type { AppRole } from "@/lib/auth/types";
import { createSupabaseWorkflowVersionRepository } from "@/lib/supabase/queries/workflow-versions";
import {
  WorkflowVersionService,
  type WorkflowVersionRecord,
} from "@/lib/workflow/versioning";
import type {
  CreateDealRequest,
  CreateDealWithEntitiesRequest,
} from "@/lib/workflow";
import { createWorkflowActionExecutor } from "@/lib/workflow/actions";
import type { WorkflowActionContext } from "@/lib/workflow/state-machine";
import { getWorkflowVersionChecksum } from "@/lib/workflow/versioning";

export type DealRow = {
   id: string;
   workflow_id: string;
   workflow_version_id: string | null;
   customer_id: string | null;
   asset_id: string | null;
   vehicle_id: string | null;
   source: string | null;
   status: string;
   op_manager_id: string | null;
   deal_number: string | null;
   created_at: string;
   updated_at: string;
   payload: Record<string, unknown> | null;
};

type CreateDealResult =
  | { success: true; deal: DealRow }
  | { success: false; statusCode: number; message: string };

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServiceClient>>;

const DEAL_NUMBER_MAX_ATTEMPTS = 50;

async function generateFormattedDealNumber(
  client: SupabaseServerClient,
  options: { createdAt: Date; vin?: string | null },
): Promise<string> {
  const { createdAt, vin = null } = options;

  for (let attempt = 1; attempt <= DEAL_NUMBER_MAX_ATTEMPTS; attempt++) {
    const candidate = buildDealNumberCandidate(createdAt, vin, attempt);
    const { count, error } = await client
      .from("deals")
      .select("id", { head: true, count: "exact" })
      .eq("deal_number", candidate);

    if (error) {
      console.error("[workflow] failed to verify deal number uniqueness", {
        candidate,
        error,
      });
      continue;
    }

    if (!count) {
      return candidate;
    }
  }

  throw new Error("Failed to generate unique deal number");
}

const DEFAULT_GUARD_PAYLOAD: Record<string, unknown> = {
  quotationPrepared: false,
  vehicle: { verified: false },
  docs: { required: { allUploaded: false } },
  risk: { approved: false },
  finance: { approved: false },
  investor: { approved: false },
  legal: { contractReady: false },
  esign: { allSigned: false },
  payments: {
    advanceReceived: false,
    supplierPaid: false,
  },
  delivery: { confirmed: false },
};

function deepMergePayload(
  base: Record<string, unknown>,
  override?: Record<string, unknown> | null,
): Record<string, unknown> {
  if (!override) {
    return { ...base };
  }

  const result: Record<string, unknown> = { ...base };

  for (const [key, value] of Object.entries(override)) {
    const current = result[key];
    if (
      value &&
      typeof value === "object" &&
      !Array.isArray(value) &&
      current &&
      typeof current === "object" &&
      !Array.isArray(current)
    ) {
      result[key] = deepMergePayload(
        current as Record<string, unknown>,
        value as Record<string, unknown>,
      );
      continue;
    }

    result[key] = value;
  }

  return result;
}

let defaultWorkflowSourceCache: string | null = null;

type PostgrestError = {
  code?: string;
  message?: string;
};

function isMissingTableError(error: unknown) {
  if (!error || typeof error !== "object") {
    return false;
  }

  const candidate = error as PostgrestError;
  return candidate.code === "PGRST205";
}

async function loadDefaultWorkflowSource(): Promise<string> {
  if (defaultWorkflowSourceCache) {
    return defaultWorkflowSourceCache;
  }

  const templatePath = path.join(
    process.cwd(),
    "docs",
    "workflow_template.yaml",
  );

  const source = await fs.readFile(templatePath, "utf8");
  defaultWorkflowSourceCache = source;
  return source;
}

type WorkflowVersionSyncOptions = {
  workflowId: string;
  sourceYaml: string;
  checksum: string;
};

function buildAutogeneratedVersionLabel(workflowId: string, checksum: string): string {
  const prefix = workflowId.replace(/[^a-zA-Z0-9_-]/g, "-");
  const timestamp = new Date()
    .toISOString()
    .replace(/\D/g, "")
    .slice(0, 12);
  return `${prefix}-${timestamp}-${checksum.slice(0, 6)}`;
}

async function activateMatchingVersion(
  service: WorkflowVersionService,
  options: WorkflowVersionSyncOptions,
): Promise<WorkflowVersionRecord | null> {
  const versions = await service.listVersions(options.workflowId);
  const match = versions.find((version) => version.checksum === options.checksum);
  if (!match) {
    return null;
  }

  await service.activateVersion(options.workflowId, match.id);
  const activated = await service.getVersionById(match.id);
  return activated ?? null;
}

export async function ensureActiveWorkflowVersion(
  service: WorkflowVersionService,
): Promise<WorkflowVersionRecord | null> {
  const workflowId = "fast-lease-v1";
  const sourceYaml = await loadDefaultWorkflowSource();
  const checksum = getWorkflowVersionChecksum(sourceYaml);

  const existing = await service.getActiveVersion(workflowId);
  if (existing && existing.checksum === checksum) {
    return existing;
  }

  if (existing) {
    console.info("[workflow] detected outdated workflow version, provisioning update", {
      workflowId,
      activeVersionId: existing.id,
    });
  } else {
    console.info("[workflow] no active workflow version found, bootstrapping default", {
      workflowId,
    });
  }

  const syncOptions: WorkflowVersionSyncOptions = {
    workflowId,
    sourceYaml,
    checksum,
  };

  try {
    const reactivated = await activateMatchingVersion(service, syncOptions);
    if (reactivated) {
      return reactivated;
    }

    const versionLabel = buildAutogeneratedVersionLabel(workflowId, checksum);
    const created = await service.createVersion({
      sourceYaml,
      version: versionLabel,
      activate: true,
    });
    return created;
  } catch (error) {
    console.error("[workflow] failed to synchronize workflow version", error);

    const fallback = await service.getActiveVersion(workflowId);
    if (fallback && fallback.checksum === checksum) {
      return fallback;
    }

    return null;
  }
}

type WorkflowContactSnapshot = {
  id: string;
  full_name: string | null;
  email: string | null;
  phone: string | null;
};

type WorkflowAssetSnapshot = {
  id: string;
  type: string | null;
  make: string | null;
  model: string | null;
  trim: string | null;
  year: number | null;
  vin: string | null;
  supplier: string | null;
  price: number | null;
  meta: Record<string, unknown> | null;
};

async function loadWorkflowContact(
  supabase: SupabaseServerClient,
  id: string,
): Promise<WorkflowContactSnapshot | null> {
  const { data, error } = await supabase
    .from("workflow_contacts")
    .select("id, full_name, email, phone")
    .eq("id", id)
    .maybeSingle();

  if (error) {
    console.error("[workflow] failed to load workflow contact", error);
    return null;
  }

  if (!data) {
    return null;
  }

  return data as WorkflowContactSnapshot;
}

async function loadWorkflowAsset(
  supabase: SupabaseServerClient,
  id: string,
): Promise<WorkflowAssetSnapshot | null> {
  const { data, error } = await supabase
    .from("workflow_assets")
    .select("id, type, make, model, trim, year, vin, supplier, price, meta")
    .eq("id", id)
    .maybeSingle();

  if (error) {
    console.error("[workflow] failed to load workflow asset", error);
    return null;
  }

  if (!data) {
    return null;
  }

  return data as WorkflowAssetSnapshot;
}

function buildPayloadEnrichment(input: {
  customer?: WorkflowContactSnapshot | null;
  vehicle?: {
    id: string | null;
    asset: WorkflowAssetSnapshot | null;
  };
}): Record<string, unknown> {
  const enrichment: Record<string, unknown> = {};

  if (input.customer) {
    enrichment.customer = {
      id: input.customer.id,
      full_name: input.customer.full_name,
      email: input.customer.email,
      phone: input.customer.phone,
    };
  }

  if (input.vehicle?.asset) {
    enrichment.vehicle = {
      id: input.vehicle.id,
      vin: input.vehicle.asset.vin,
      make: input.vehicle.asset.make,
      model: input.vehicle.asset.model,
      trim: input.vehicle.asset.trim,
      year: input.vehicle.asset.year,
      supplier: input.vehicle.asset.supplier,
      price: input.vehicle.asset.price,
      meta: input.vehicle.asset.meta ?? {},
    };
  }

  return enrichment;
}

function resolveActorRole(role?: string | null): AppRole {
  if (!role) {
    return "OP_MANAGER";
  }
  const normalized = role.trim().toUpperCase();
  if (
    normalized === "ADMIN" ||
    normalized === "OP_MANAGER" ||
    normalized === "SUPPORT" ||
    normalized === "FINANCE" ||
    normalized === "TECH_SPECIALIST" ||
    normalized === "RISK_MANAGER" ||
    normalized === "INVESTOR" ||
    normalized === "LEGAL" ||
    normalized === "ACCOUNTING" ||
    normalized === "CLIENT"
  ) {
    return normalized as AppRole;
  }
  return "OP_MANAGER";
}

export async function createDealWithWorkflow(
  payload: CreateDealRequest,
): Promise<CreateDealResult> {
  try {
    const supabase = await createSupabaseServiceClient();
    const versionService = new WorkflowVersionService(
      createSupabaseWorkflowVersionRepository(supabase),
    );

    const activeVersion = await ensureActiveWorkflowVersion(versionService);

    if (!activeVersion) {
      return {
        success: false,
        statusCode: 500,
        message: "Workflow version is not configured",
      };
    }

    let customerId: string | null = null;
    let assetId: string | null = null;
    let vehicleId: string | null = null;
    let createdCustomer = false;
    let createdAsset = false;

    let customerSnapshot: WorkflowContactSnapshot | null = null;
    let assetSnapshot: WorkflowAssetSnapshot | null = null;

    if ("customer_id" in payload && "asset_id" in payload) {
      customerId = payload.customer_id;
      assetId = payload.asset_id;
      customerSnapshot = await loadWorkflowContact(supabase, customerId);
      assetSnapshot = await loadWorkflowAsset(supabase, assetId);

      if (!customerSnapshot) {
        return {
          success: false,
          statusCode: 404,
          message: "Referenced customer not found",
        };
      }

      if (!assetSnapshot) {
        return {
          success: false,
          statusCode: 404,
          message: "Referenced asset not found",
        };
      }
    } else {
      const { customer, asset } = payload as CreateDealWithEntitiesRequest;

      const customerInsert = await supabase
        .from("workflow_contacts")
        .insert({
          full_name: customer.full_name,
          email: customer.email ?? null,
          phone: customer.phone ?? null,
        })
        .select("id, full_name, email, phone")
        .single();

      if (customerInsert.error || !customerInsert.data) {
        if (isMissingTableError(customerInsert.error)) {
          console.warn(
            "[workflow] skipping contact creation – table missing",
            customerInsert.error,
          );
        } else {
          console.error("[workflow] failed to create contact", customerInsert.error);
          return {
            success: false,
            statusCode: 500,
            message: "Failed to create contact",
          };
        }
      } else {
        customerId = customerInsert.data.id;
        createdCustomer = true;
        customerSnapshot = customerInsert.data as WorkflowContactSnapshot;
      }

      const assetInsert = await supabase
        .from("workflow_assets")
        .insert({
          type: asset.type ?? "VEHICLE",
          make: asset.make,
          model: asset.model,
          trim: asset.trim ?? null,
          year: asset.year ?? null,
          supplier: asset.supplier ?? null,
          price: asset.price ?? null,
          vin: asset.vin ?? null,
          meta: asset.meta ?? null,
        })
        .select("id, type, make, model, trim, year, vin, supplier, price, meta")
        .single();

      if (assetInsert.error || !assetInsert.data) {
        if (isMissingTableError(assetInsert.error)) {
          console.warn(
            "[workflow] skipping asset creation – table missing",
            assetInsert.error,
          );
        } else {
          if (createdCustomer && customerId) {
            const cleanupContact = await supabase
              .from("workflow_contacts")
              .delete()
              .eq("id", customerId);
            if (cleanupContact.error) {
              console.error(
                "[workflow] failed to cleanup contact after asset error",
                cleanupContact.error,
              );
            }
            customerId = null;
            createdCustomer = false;
          }

          console.error("[workflow] failed to create asset", assetInsert.error);
          return {
            success: false,
            statusCode: 500,
            message: "Failed to create asset",
          };
        }
      } else {
        assetId = assetInsert.data.id;
        createdAsset = true;
        assetSnapshot = assetInsert.data as WorkflowAssetSnapshot;
      }
    }

    if (assetId) {
      if (!assetSnapshot) {
        assetSnapshot = await loadWorkflowAsset(supabase, assetId);
      }

      if (assetSnapshot) {
        const assetMeta = (assetSnapshot.meta as Record<string, unknown> | null) ?? null;
        const mileageRaw = assetMeta?.mileage_value as number | string | undefined;
        const mileageValue =
          typeof mileageRaw === "number"
            ? mileageRaw
            : typeof mileageRaw === "string"
              ? Number.parseFloat(mileageRaw)
              : null;
        const vehicleInsert = await supabase
          .from("vehicles")
          .upsert(
            {
              vin: assetSnapshot.vin ?? null,
              make: assetSnapshot.make ?? null,
              model: assetSnapshot.model ?? null,
              variant: assetSnapshot.trim ?? null,
              year: assetSnapshot.year ?? null,
              status: "reserved",
              mileage: mileageValue ?? null,
              features: assetMeta ?? {},
            },
            assetSnapshot.vin
              ? { onConflict: "vin" }
              : undefined,
          )
          .select("id")
          .maybeSingle();

        if (vehicleInsert.error) {
          console.error("[workflow] failed to create vehicle record", vehicleInsert.error);
          if (createdCustomer && customerId) {
            await supabase.from("workflow_contacts").delete().eq("id", customerId);
          }
          if (createdAsset && assetId) {
            await supabase.from("workflow_assets").delete().eq("id", assetId);
          }
          return {
            success: false,
            statusCode: 500,
            message: "Failed to create vehicle record",
          };
        }

        vehicleId = vehicleInsert.data?.id ?? null;
      }
    }

    const mergedPayload = deepMergePayload(
      DEFAULT_GUARD_PAYLOAD,
      payload.payload ?? null,
    );

    const enrichedPayload = deepMergePayload(
      mergedPayload,
      buildPayloadEnrichment({
        customer: customerSnapshot ?? undefined,
        vehicle: {
          id: vehicleId ?? assetId ?? null,
          asset: assetSnapshot ?? null,
        },
      }),
    );

    const actorRole = resolveActorRole("OP_MANAGER");

    const dealNumber = await generateFormattedDealNumber(supabase, {
      createdAt: new Date(),
      vin: assetSnapshot?.vin ?? null,
    });
    console.log(`[DEBUG] Generated formatted deal number: ${dealNumber}`);

    const { data, error } = await supabase
      .from("deals")
      .insert({
        workflow_id: activeVersion.workflowId,
        workflow_version_id: activeVersion.id,
        customer_id: customerId,
        asset_id: assetId,
        vehicle_id: vehicleId,
        source: payload.source,
        status: "NEW",
        op_manager_id: payload.op_manager_id ?? null,
        deal_number: dealNumber,
        payload: enrichedPayload,
      })
      .select(
        "id, workflow_id, workflow_version_id, customer_id, asset_id, vehicle_id, source, status, op_manager_id, deal_number, created_at, updated_at, payload",
      )
      .single<DealRow>();

    if (error || !data) {
      console.error(`[DEBUG] failed to create deal in database:`, error);
      if (createdCustomer && customerId) {
        const cleanupContact = await supabase
          .from("workflow_contacts")
          .delete()
          .eq("id", customerId);
        if (cleanupContact.error) {
          console.error(
            "[workflow] failed to cleanup contact after deal error",
            cleanupContact.error,
          );
        }
      }
      if (createdAsset && assetId) {
        const cleanupAsset = await supabase
          .from("workflow_assets")
          .delete()
          .eq("id", assetId);
        if (cleanupAsset.error) {
          console.error(
            "[workflow] failed to cleanup asset after deal error",
            cleanupAsset.error,
          );
        }
      }
      console.error("[workflow] failed to create deal", error);
      return {
        success: false,
        statusCode: 500,
        message: "Failed to create deal",
      };
    }

    try {
      const newStage = activeVersion.template.stages?.NEW;
      if (newStage?.entryActions?.length) {
        console.log(
          "[workflow] executing entry actions for NEW stage",
          newStage.entryActions.map((action) => action.type),
        );
        const actionExecutor = createWorkflowActionExecutor(supabase);
        const actionContext: WorkflowActionContext = {
          actorRole,
          actorId: payload.op_manager_id ?? undefined,
          dealId: data.id,
          transition: {
            from: "NEW",
            to: "NEW",
          },
          payload: enrichedPayload,
          template: activeVersion.template,
        };

        for (const action of newStage.entryActions) {
          console.log("[workflow] executing action", action.type);
          await actionExecutor(action, actionContext);
        }
      }
    } catch (actionError) {
      console.error("[workflow] failed to execute entry actions for new deal", actionError);
    }

    console.log(`[DEBUG] successfully created deal:`, data.id, `with deal_number:`, data.deal_number);
    return { success: true, deal: data };
  } catch (error) {
    console.error("[workflow] unexpected error while creating deal", error);
    return {
      success: false,
      statusCode: 500,
      message: "Unexpected error while creating deal",
    };
  }
}

Я проанализировал архитектуру workflow и вижу, что система использует версионирование (`workflow_version_id` в таблице `deals`) и механизм идемпотентности (`action_hash` в задачах). Это отличные новости, так как они позволяют безопасно синхронизировать данные.

Вот план синхронизации существующих сделок с новым флоу:

### Стратегия: "Soft Resync"
Вместо жесткой миграции мы обновим версию workflow у активных сделок и перезапустим генерацию задач для их *текущего* статуса. Благодаря `action_hash`, старые (уже созданные) задачи не задублируются, а новые (добавленные в схему) создадутся.

### План реализации

1.  **Доработка `WorkflowService`** (`lib/workflow/service.ts`)
    *   Добавить метод `resyncDeal(dealId: string)`, который:
        *   Получает последнюю *активную* версию workflow.
        *   Обновляет `workflow_version_id` у сделки.
        *   Загружает определение *текущего* статуса сделки из новой версии.
        *   Принудительно запускает `entryActions` (создание задач) для этого статуса.

2.  **Создание API для массовой синхронизации**
    *   Создать временный или админский роут `app/api/workflow/maintenance/sync/route.ts`.
    *   Логика: Найти все сделки в активных статусах (не `CANCELLED` и не `ACTIVE` final), у которых версия отличается от актуальной, и вызвать для них `resyncDeal`.

3.  **Запуск и проверка**
    *   Запустить синхронизацию на одной тестовой сделке.
    *   Убедиться, что недостающие задачи появились, а существующие остались без изменений.
    *   Запустить массово.

### Почему это безопасно
Система уже использует `action_hash` (хэш из `deal_id + transition + template_id`). Если задача уже была создана ранее, повторный запуск `entryAction` проигнорирует её создание. Если вы добавили *новые* задачи в этот этап, они будут иметь новый хэш и успешно создадутся.
